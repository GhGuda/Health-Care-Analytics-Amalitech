# 3.4: ETL Logic

1. Dimension Load Logic
    1.1 How do you populate dim_patient from the patients table?
    The dim_patient table is populated by extracting data from
    the OLTP patients table. Each patient record is checked against
    existing records using the natural key (patient_id or mrn). 
    New patients are inserted with a new surrogate patient_key, 
    while existing patients are updated only if descriptive attributes change.


    1.2 How do you populate dim_date (one-time load)?
    The dim_date table is populated using a one-time calendar
    generation process rather than from transactional data. 
    A continuous range of dates is generated, and for each date, 
    derived attributes such as month, quarter, year, and day of week are calculated and stored.


    1.3 How do you handle updates to dimensions?
    Dimension updates are handled using a Type 1 slowly changing dimension approach. 
    When descriptive attributes change, the existing dimension record is updated in 
    place, ensuring the latest information is available for reporting.


 2. Fact Table Load Logic
 
    2.1 For each encounter, how do you look up dimension keys?
    For each encounter, dimension surrogate keys are retrieved by 
    matching natural keys from the source tables to their corresponding 
    dimension tables. These surrogate keys are then used when inserting 
    records into the fact_encounters table.

    2.2 How do you calculate pre-aggregated metrics?
    encounter_count → always set to 1
    diagnosis_count → count rows in encounter_diagnoses for that encounter
    procedure_count → count rows in encounter_procedures for that encounter
    total_allowed_amount → sum billing amounts for that encounter
    length_of_stay → discharge_date − encounter_date

    Pre-aggregated metrics are calculated during the ETL process. 
    Counts of diagnoses and procedures are computed per encounter, 
    billing amounts are summed to produce total allowed revenue, 
    and length of stay is calculated from encounter and discharge dates. 
    These metrics are stored directly in the fact table to avoid expensive runtime aggregations.

    2.3 How do you handle missing data?
    Missing or unmatched dimension values are handled by mapping 
    them to predefined “Unknown” dimension records. Missing numeric 
    metrics are stored as zero or NULL to maintain data 
    integrity without blocking the load process.


3. Bridge Table Load Logic

    3.1 How do you populate bridge_encounter_diagnoses?
    The bridge_encounter_diagnoses table is populated by linking encounter
    records to their associated diagnoses. Each diagnosis is mapped to its
    surrogate key and inserted alongside the corresponding encounter key, 
    preserving the many-to-many relationship.

    3.2 How do you populate bridge_encounter_procedures?
    The bridge_encounter_procedures table is populated by associating
    encounters with procedures performed during the visit. Each procedure is 
    mapped to its dimension surrogate key and linked to the corresponding encounter record.


4. Refresh Strategy

    4.1 How often would you load?
    The ETL process is designed to run daily using an incremental load strategy. 
    Only new or changed records since the last load are processed, reducing processing time and system impact.

    4.2 How would you handle late-arriving facts? 
    Late-arriving facts are initially loaded using default “Unknown” dimension keys. 
    Once the corresponding dimension data becomes available, the fact records 
    are updated to reference the correct surrogate keys.


    